"""

This module contains shared code for the reader modules.

For now, it only is used by readers.lexisnexis.py, but med_read.py and else_read.py
contain some duplications of the code in this module.

"""

import shlex, codecs


class Tag():

    """
    Contains information for individual lines in a fact file. The fact file can either
    contain the BAE-generated output or the complete standoff output as generated by
    utils/create-standoff.pl."""

    def __init__(self, text):
        split_text = shlex.split(text)
        try:
            # this is for the create_standoff.pl output
            self.start_index = int(split_text[0])
            self.end_index = int(split_text[1])
            self.name = split_text[2]
            self.attributes = split_text[3:]
        except IndexError:
            #  assume this is a malformed tag if there are less then three tokens in the line
            self.start_index = None
            self.end_index = None
            self.name = None
            self.attributes = None
        except ValueError:
            # this is for the BAE format
            self.name = split_text[0]
            #self.attributes = dict(map(lambda x: str.split(x, "=", 1), split_text[1:]))
            self.attributes = dict([x.split('=',1) for x in split_text[1:]])
            # the following is a simplicifcation that works for patents and pubmed, but it
            # needs to be tested for elsevier2
            self.start_index = int(self.attributes.get("START", '-1'))
            self.end_index = int(self.attributes.get("END", '-1'))

    def __str__(self):
        return "[%d %d %s type=%s]" % (self.start_index, self.end_index, self.name, 
                                       self.attributes.get('TYPE', None))
            
    def __len__(self):
        return self.end_index - self.start_index

    def text(self, doc):
        return doc[self.start_index:self.end_index]

    def is_abstract(self):
        """Return True if self is an abstract, False otherwise. Can deal with BAE fact
        files and output of utils/create_standoff.pl."""
        if self.name.lower() == 'abstract':
            return True
        if self.name == 'STRUCTURE' and self.attributes['TYPE'] == 'ABSTRACT':
            return True
        return False

    
def load_data(text_file, fact_file):
    """Returns a tuple of the text as a unicode string and a list of Tag instances created
    from the fact file."""
    text = codecs.open(text_file, encoding="utf-8").read()
    tags = [ Tag(line) for line in open(fact_file) if line.strip() != '' ]
    return (text, tags)

def find_abstracts(tags):
    """Returns all tags that are abstract tags."""
    return [ t for t in tags if t.is_abstract()]

def load_articles(basename_file="files.txt"):
    articles = []
    for line in open(basename_file):
        basename = line.strip().split("/")[-1]
        articles.append(load_data(basename))
    return articles

def tags_with_name(tags, tagname):
    """Returns all elements from tags with name == tagname"""
    return [t for t in tags if t.name == tagname]

def tags_with_type(tags, tagtype):
    """Returns all elements from tags with type == typename"""
    return [t for t in tags if t.attributes["TYPE"] == tagtype]

def tags_with_matching_type(tags, tagtype, p1, p2):
    """Returns all elements from tags with type[p1:p2] == typename"""
    return [t for t in tags if t.attributes["TYPE"][p1:p2] == tagtype]
