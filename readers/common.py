"""

This module contains shared code for the reader modules.

"""

# TODO: there are still some duplications of code in readers/elsevier2.py


import shlex, codecs


class Tag():

    """
    Contains information for individual lines in a fact file. The fact file can either
    contain the BAE-generated output or the complete standoff output as generated by
    utils/standoff"""

    def __init__(self, text, fact_type):
        split_text = shlex.split(text)
        self.name = split_text[0]
        self.attributes = dict([x.split('=',1) for x in split_text[1:]])
        if fact_type == 'BASIC':
            p1 = int(self.attributes.get("standoff:offset", '-1'))
            length = int(self.attributes.get("standoff:length", '-1'))
            if p1 == -1 or length == -1:
                # for unexplained reasons, the standoff.xsl script sometimes uses standoff1
                # instead of standoff in attribute names, this is the workaround for that
                p1 = int(self.attributes.get("standoff1:offset", '-1'))
                length = int(self.attributes.get("standoff1:length", '-1'))
            self.start_index = p1
            self.end_index = p1 + length if (p1 > -1 and length > -1) else -1
        if fact_type == 'BAE':
            # the following is a simplicifcation that works for patents and pubmed, but it
            # needs to be tested for elsevier2
            self.start_index = int(self.attributes.get("START", '-1'))
            self.end_index = int(self.attributes.get("END", '-1'))

    def __str__(self):
        return "[%d %d %s type=%s]" % (self.start_index, self.end_index, self.name, 
                                       self.attributes.get('TYPE', None))
            
    def __len__(self):
        return self.end_index - self.start_index

    def text(self, doc):
        return doc[self.start_index:self.end_index]

    def attr(self, attr):
        return self.attributes.get(attr, None)

    def is_contained_in(self, p1, p2):
        """Return True if self is contained in p1 and p2."""
        if p1 <= self.start_index <= p2 and p1 <= self.end_index <= p2:
            return True
        return False

    def is_not_contained_in(self, p1, p2):
        """Return True if self is not contained in p1 and p2."""
        return not self.is_contained_in(p1, p2)

    def is_abstract(self):
        """Return True if self is an abstract, False otherwise. Can deal with BAE fact
        files and output of utils/standoff."""
        if self.name.lower() == 'abstract':
            return True
        if self.name == 'STRUCTURE' and self.attributes['TYPE'] == 'ABSTRACT':
            return True
        return False

    
def load_data(text_file, fact_file, fact_type='BAE'):
    """Returns a tuple of the text as a unicode string and a list of Tag instances created
    from the fact file."""
    text = codecs.open(text_file, encoding="utf-8").read()
    tags = [ Tag(line, fact_type) for line in open(fact_file) if line.strip() != '' ]
    return (text, tags)

def find_abstracts(tags):
    """Returns all tags that are abstract tags."""
    return [ t for t in tags if t.is_abstract()]

def load_articles(basename_file="files.txt"):
    articles = []
    for line in open(basename_file):
        basename = line.strip().split("/")[-1]
        articles.append(load_data(basename))
    return articles

def tags_with_name(tags, tagname):
    """Returns all elements from tags with name == tagname"""
    return [t for t in tags if t.name == tagname]

def tags_with_type(tags, tagtype):
    """Returns all elements from tags with type == typename"""
    return [t for t in tags if t.attributes["TYPE"] == tagtype]

def tags_with_matching_type(tags, tagtype, p1, p2):
    """Returns all elements from tags with type[p1:p2] == typename"""
    return [t for t in tags if t.attributes["TYPE"][p1:p2] == tagtype]

def open_write_file(filename, encoding='utf-8'):
    """Open a file using codecs and return the filehandle."""
    return codecs.open(filename, 'w', encoding)

